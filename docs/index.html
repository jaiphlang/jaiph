<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jaiph — AI Workflow DSL</title>

    <style>
        :root {
            --navy: #1f2a37;
            --navy-light: #2b3a4d;
            --orange: #fca228;
            --orange-soft: #e8a75a;
            --bg: #f4f1ec;
            --text: #2a2a2a;
            --muted: #6b7280;
            --link: #5389b0;
            --success: #16a34a;
        }

        html {
            background: linear-gradient(to bottom, var(--muted) 0%, var(--bg) 640px, var(--bg) 100%);
            background-attachment: fixed;
        }

        * {
            box-sizing: border-box;
        }

        img {
            max-width: 100%;
            height: auto;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: var(--text);
            line-height: 1.6;
            font-size: 1.25rem;
        }

        header {
            padding: 3rem 1.5rem;
            text-align: center;
            color: var(--text);
        }

        .logo {
            font-size: 2.8rem;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .logo span {
            color: var(--orange);
        }

        .tagline {
            margin-top: 1rem;
            font-size: 1.5rem;
            color: var(--text);
            font-weight: bold;
            text-shadow: 1px 0px 3px var(--bg);
        }

        .tagline .separator {
            margin: 0 1rem;
            color: var(--orange);
            line-height: inherit;
            text-shadow: none;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2.5rem 1.5rem;
        }

        h2 {
            color: var(--navy);
            text-shadow: 1px 0px 3px var(--bg);
            margin-top: 2.5rem;
        }

        a {
            color: var(--link);
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem 2.5rem;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.05);
            margin-top: 1rem;
        }

        .small {
            font-size: 1rem;
            color: var(--muted);
        }

        .warning {
            color: var(--orange-soft);
        }

        pre {
            background: #f6f8fa;
            color: #24292f;
            padding: 2rem 0;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9rem;
            border: 1px solid #d0d7de;
            position: relative;
        }

        code {
            font-family: "Fira Code", monospace;
            color: #24292f;
        }

        code:not(pre code) {
            font-size: 0.9rem;
            background: #f6f8fa;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            padding: 0.2rem 0.35rem;
        }

        pre code {
            display: block;
            white-space: pre;
            counter-reset: line;
        }

        pre code .code-line {
            display: block;
            padding-left: 4em;
            position: relative;
            white-space: pre;
        }

        pre code .code-line::before {
            counter-increment: line;
            content: counter(line);
            color: #8c959f;
            position: absolute;
            left: 0;
            width: 2.25rem;
            text-align: right;
            user-select: none;
        }

        .jaiph-run .run-time {
            color: var(--muted);
        }

        .jaiph-run .run-pass {
            color: var(--success);
            font-weight: 600;
        }

        .jaiph-run .run-keyword {
            font-weight: 600;
        }

        .copy-code-button {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            background: white;
            color: #24292f;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 0.25rem 0.6rem;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .copy-code-button:hover {
            background: #f3f4f6;
        }

        .code-tab-list {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .code-tab-button {
            border: 1px solid #d0d7de;
            border-radius: 8px;
            background: white;
            color: var(--muted);
            font-size: 0.9rem;
            font-weight: 600;
            font-family: "Fira Code", monospace;
            padding: 0.45rem 0.9rem;
            cursor: pointer;
        }

        .code-tab-button.is-active {
            background: #e7f3ff;
            border-color: #80bfff;
            color: #0550ae;
        }

        .code-tab-hint {
            color: var(--muted);
            font-size: 0.85rem;
        }

        .code-tab-panel {
            display: none;
        }

        .code-tab-panel.is-active {
            display: block;
        }

        .primitive-list {
            margin: 0.5rem 0 0;
        }

        .primitive-list dt {
            font-weight: 600;
            margin-top: 0.65rem;
        }

        .primitive-list dd {
            margin: 0.2rem 0 0.6rem 1.25rem;
            color: var(--text);
        }

        .footer {
            margin-top: 4rem;
            padding: 2rem;
            text-align: center;
            font-size: 0.9rem;
            color: var(--muted);
        }

        .button {
            display: inline-block;
            margin-top: 1rem;
            padding: 0.6rem 1.2rem;
            background: var(--orange);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            transition: 0.2s ease;
        }

        .button:hover {
            background: var(--orange-soft);
        }

        header h1 img {
            width: min(640px, 100%);
            height: auto;
        }

        @media (max-width: 768px) {
            body {
                font-size: 1rem;
            }

            header {
                padding: 2rem 1rem;
            }

            .tagline {
                font-size: 1rem;
                line-height: 1.5;
            }

            .tagline .separator {
                margin: 0 0.4rem;
            }

            .container {
                padding: 1.5rem 1rem;
            }

            .card {
                padding: 1rem 1rem;
                border-radius: 8px;
            }

            h2 {
                margin-top: 1.8rem;
                font-size: 1.35rem;
            }

            pre {
                font-size: 0.82rem;
                padding: 1.5rem 0;
            }

            pre code .code-line {
                padding-left: 3.2em;
            }

            .code-tab-list {
                flex-wrap: wrap;
            }

            .code-tab-button {
                font-size: 0.82rem;
                padding: 0.4rem 0.75rem;
            }
        }


        /* Keywords */
        .ralph-keyword {
            color: #cf222e;
            font-weight: 600;
        }

        /* Rule / workflow names */
        .ralph-definition {
            color: #8250df;
        }

        /* Qualified prefix */
        .ralph-qualifier {
            color: #6639ba;
        }

        /* Identifier */
        .ralph-identifier {
            color: #0550ae;
        }

        /* Strings */
        .ralph-string {
            color: #0a3069;
        }

        /* Comments */
        .ralph-comment {
            color: #6e7781;
            font-style: italic;
        }
    </style>
</head>

<body>

    <header>
        <h1><img src="logo.png" alt="Jaiph" /></h1>
        <div class="tagline">
            Open Source<span class="separator">•</span>Powerful<span class="separator">•</span>Friendly!
        </div>
    </header>

    <div class="container">

        <section>
            <h2>What is Jaiph?</h2>
            <div class="card">
                <p>
                    <strong>Jaiph</strong> is a composable scripting language and runtime for defining and orchestrating
                    AI agent workflows.
                </p>
                <p>
                    It combines the power of AI prompts with strict checks and orchestration to create portable and
                    easy-to-understand AI agent workflows. It support native bash commands and compiles to pure bash,
                    making it fully compatible with existing shell environments.
                </p>
                <p class="small"><strong class="warning">⚠ Jaiph is still in an early stage.</strong><br />You may
                    expect breaking changes. You may also have a great impact as an early contributor.</p>
                <p>
                    <a href="https://jaiph.org/getting-started" target="_blank" rel="noopener noreferrer"
                        class="button">Docs</a>
                    <a href="https://github.com/jaiphlang/jaiph" target="_blank" rel="noopener noreferrer"
                        class="button">GitHub</a>
                    <a href="https://marketplace.visualstudio.com/items?itemName=jaiph.jaiph-syntax-vscode"
                        target="_blank" rel="noopener noreferrer" class="button">VSC Extension</a>
                    <a href="https://jaiph.org/jaiph-skill.md" target="_blank" rel="noopener noreferrer"
                        class="button">Agent Skill</a>
                </p>
            </div>
        </section>

        <section>
            <h2>Sample run</h2>
            <div class="card">
                <p>This is the sample output from running a Jaiph workflow:</p>
                <pre><code class="jaiph-run">➜  jaiph git:(development) .jaiph/docs_parity.jh 
<span class="run-keyword">workflow</span> default
├── <span class="run-keyword">rule</span> tests_pass <span class="run-time">(4s)</span>
├── <span class="run-keyword">rule</span> e2e_tests_pass <span class="run-time">(5s)</span>
├── <span class="run-keyword">rule</span> docs_files_present <span class="run-time">(0s)</span>
├── <span class="run-keyword">function</span> changed_files <span class="run-time">(0s)</span>
├── <span class="run-keyword">prompt</span> prompt <span class="run-time">(168s)</span>
├── <span class="run-keyword">rule</span> only_expected_docs_changed_after_prompt <span class="run-time">(0s)</span>
├── <span class="run-keyword">rule</span> tests_pass <span class="run-time">(4s)</span>
├── <span class="run-keyword">rule</span> e2e_tests_pass <span class="run-time">(5s)</span>
<span class="run-pass">✓ PASS</span> <span class="run-keyword">workflow</span> default <span class="run-time">(3m 6s)</span></code></pre>
            </div>
        </section>

        <section>
            <h2>Sample workflow</h2>
            <div class="card">
                <div class="code-tab-list">
                    <button type="button" class="code-tab-button is-active" data-target="main-jph">main.jh</button>
                    <span class="code-tab-hint">transpiles to: </span>
                    <button type="button" class="code-tab-button" data-target="main-sh">main.sh</button>
                </div>

                <div class="code-tab-panel is-active" data-panel="main-jph">
                    <pre><code class="language-jaiph">#!/usr/bin/env jaiph

import "bootstrap_project.jh" as bootstrap
import "tools/security.jh" as security

# Validates local build prerequisites.
rule project_ready {
  test -f "package.json"
  test -n "$NODE_ENV"
}

# Verifies the project compiles successfully.
rule build_passes {
  npm run build
}

# Orchestrates checks, prompt execution, and docs refresh.
# Arguments:
#   $1: Feature requirements passed to the prompt.
workflow default {
  if ! ensure project_ready; then
    run bootstrap.nodejs
  fi
  
  prompt "
    Build the application using best practices.
    Follow requirements: $1
  "
  
  ensure build_passes
  ensure security.scan_passes

  run update_docs
}

# Refreshes documentation after a successful build.
workflow update_docs {
  prompt "Update docs"
}</code></pre>
                </div>

                <div class="code-tab-panel" data-panel="main-sh">
                    <pre><code class="language-bash">set -euo pipefail
jaiph_stdlib_path="${JAIPH_STDLIB:-$HOME/.local/bin/jaiph_stdlib.sh}"
if [[ ! -f "$jaiph_stdlib_path" ]]; then
  echo "jai: stdlib not found at $jaiph_stdlib_path (set JAIPH_STDLIB or reinstall jaiph)" >&2
  exit 1
fi
source "$jaiph_stdlib_path"
if [[ "$(jaiph__runtime_api)" != "1" ]]; then
  echo "jai: incompatible jaiph stdlib runtime (required api=1)" >&2
  exit 1
fi
source "$(dirname "${BASH_SOURCE[0]}")/bootstrap_project.sh"
source "$(dirname "${BASH_SOURCE[0]}")/tools/security.sh"

# Validates local build prerequisites.
main__rule_project_ready__impl() {
  test -f "package.json"
  test -n "$NODE_ENV"
}

main__rule_project_ready() {
  jaiph__run_step main__rule_project_ready jaiph__execute_readonly main__rule_project_ready__impl
}

# Verifies the project compiles successfully.
main__rule_build_passes__impl() {
  npm run build
}

main__rule_build_passes() {
  jaiph__run_step main__rule_build_passes jaiph__execute_readonly main__rule_build_passes__impl
}

# Orchestrates checks, prompt execution, and docs refresh.
# Arguments:
#   $1: Feature requirements passed to the prompt.
main__workflow_default__impl() {
  if ! main__rule_project_ready; then
    bootstrap_project__workflow_nodejs
  fi
  jaiph__prompt "
    Build the application using best practices.
    Follow requirements: $1
  "
  main__rule_build_passes
  tools__security__rule_scan_passes
  main__workflow_update_docs
}

main__workflow_default() {
  jaiph__run_step main__workflow_default main__workflow_default__impl "$@"
}

# Refreshes documentation after a successful build.
main__workflow_update_docs__impl() {
  jaiph__prompt "Update docs"
}

main__workflow_update_docs() {
  jaiph__run_step main__workflow_update_docs main__workflow_update_docs__impl "$@"
}</code></pre>
                </div>

            </div>
        </section>

        <section>
            <h2>Getting started</h2>
            <div class="card">
                <p>
                    The installation below uses Jaiph from the main branch in the GitHub repository:
                    <a href="https://github.com/jaiphlang/jaiph" target="_blank"
                        rel="noopener noreferrer">https://github.com/jaiphlang/jaiph</a>.
                    The specification is still in flux and may break in the future.
                    You may expect breaking changes.
                </p>
                <h3>Installation</h3>
                <pre><code class="language-bash">curl -fsSL https://jaiph.org/install | bash</code></pre>
                <p>
                    Then verify the installation:
                </p>
                <pre><code class="language-bash">jaiph --version</code></pre>
                <p>Switch installed version:</p>
                <pre><code class="language-bash">jaiph use nightly
jaiph use 0.2.0</code></pre>
                <p>In case of an error, check if <code>~/.local/bin</code> is in your PATH. This is the default
                    installation directory.</p>
                <p>Installation places both the <code>jaiph</code> CLI and the global runtime stdlib
                    (<code>jaiph_stdlib.sh</code>) in <code>~/.local/bin/</code>.</p>
                <h3>Running a workflow</h3>
                <pre><code class="language-bash">./path/to/main.jh "feature request or task"</code></pre>
                <p><strong>Argument passing:</strong> values map like bash scripts (<code>$1</code>, <code>$2</code>,
                    <code>"$@"</code>).
                </p>
                <p><strong>Entrypoint resolution:</strong> executable <code>.jh</code> files with shebang run
                    <code>workflow default</code>. You can also use <code>jaiph run path/to/file.jh</code> with the
                    same argument semantics.
                </p>
                <h3>Initialize Jaiph workspace</h3>
                <pre><code class="language-bash">jaiph init</code></pre>
                <p>This creates <code>.jaiph/bootstrap.jh</code>, <code>.jaiph/config.toml</code>, and
                    <code>.jaiph/jaiph-skill.md</code> (synced from local Jaiph installation).
                </p>
                <p>Then run:</p>
                <pre><code class="language-bash">./.jaiph/bootstrap.jh</code></pre>
                <p>This asks an agent to detect project configuration and bootstrap recommended Jaiph workflows for
                    feature implementation.</p>
                <p>Tip: add <code>.jaiph/runs/</code> to your <code>.gitignore</code>.</p>
                <h3>Configuration</h3>
                <p>Jaiph supports TOML configuration in two scopes:</p>
                <ul>
                    <li>Global: <code>${XDG_CONFIG_HOME:-~/.config}/jaiph/config.toml</code></li>
                    <li>Local: <code>.jaiph/config.toml</code> (workspace root)</li>
                </ul>
                <p>Local config overrides global config. For supported keys and precedence, read
                    <a href="configuration">configuration docs</a>.
                </p>
                <p>For command syntax and flags, read
                    <a href="cli">CLI reference</a>.
                </p>
            </div>
        </section>

        <section>
            <h2>Documentation</h2>
            <div class="card">
                <dl class="primitive-list">
                    <dt><code>import "file.jh" as alias</code></dt>
                    <dd>Imports rules and workflows from another Jaiph module under an alias. Jaiph compiles each module
                        to a single shell file, and verifies the import at compile time.</dd>

                    <dt><code>rule name { ... }</code></dt>
                    <dd>Defines a reusable check/action that returns a shell exit code. The rule is executed in a
                        read-only subshell, and its stdout is preserved. The rule fails if the command returns a
                        non-zero
                        exit code. Rules can consume positional parameters (<code>$1</code>, <code>$2</code>,
                        <code>"$@"</code>) forwarded by <code>ensure</code>.
                    </dd>

                    <dt><code>workflow name { ... }</code></dt>
                    <dd>Defines an orchestration entrypoint made of ordered steps. As opposed to rules, workflows can
                        change the state of the system and are not restricted to read-only operations. Workflows fail if
                        the script returns a non-zero exit code.

                    <dt><code>function name() { ... }</code></dt>
                    <dd>Defines a reusable writable shell function. Functions can be called from workflows/rules and are
                        tracked as regular Jaiph steps.</dd>

                    <dt><code>ensure ref [args...]</code></dt>
                    <dd>Executes a rule in a workflow or another rule, optionally forwarding arguments (for example:
                        <code>ensure my_rule "$1"</code>).
                    </dd>

                    <dt><code>run ref</code></dt>
                    <dd>Executes another workflow from a workflow. <code>run</code> is not allowed inside a rule; use
                        <code>ensure</code> to call another rule or move the call to a workflow.
                    </dd>

                    <dt><code>prompt "..."</code></dt>
                    <dd>Sends prompt text to the configured agent command (with optional model from config) and stores
                        prompt stdout/stderr in
                        <code>.jaiph/runs/</code> step logs (for example:
                        <code>*-jaiph__prompt.out</code> and <code>*-jaiph__prompt.err</code>). Jaiph also writes
                        <code>run_summary.jsonl</code> in each run directory and skips creating empty step log files.
                    </dd>
                </dl>

                <p>All language primitives can be freely combined with bash code—they are not isolated or blocking, but
                    instead are interoperable with standard shell scripting within your workflows and rules.</p>
                <p><code>jaiph run</code> progress is event-driven: TTY mode keeps one live running-step line, while
                    non-TTY mode prints one completion line per finished step.</p>
                <h3>Known limitations and gotchas</h3>
                <ul>
                    <li><strong>Parser limitation:</strong> inline brace-group short-circuit patterns like
                        <code>cmd || { ... }</code> are not supported in <code>.jh</code> files yet. Use explicit
                        conditionals such as <code>if ! cmd; then ...; fi</code> instead.
                    </li>
                    <li><strong>Entrypoint naming:</strong> <code>jaiph run</code> searches for
                        <code>workflow default</code> as the entrypoint for runnable files. If the file does not contain
                        a default entrypoint, the command will fail.
                    </li>
                </ul>

                <p>
                    Additional references:
                    <a href="grammar">Grammar</a>
                    ·
                    <a href="jaiph-skill.md">Agent bootstrap guide</a>
                    ·
                    <a href="configuration">Configuration</a>
                    ·
                    <a href="cli">CLI reference</a>
                </p>
                <a href="https://github.com/jaiphlang/jaiph/tree/main/docs" target="_blank" rel="noopener noreferrer"
                    class="button">Open docs repository</a>
            </div>
        </section>

    </div>

    <div class="footer">
        © 2026 Jaiph — Open Source · Powerful · Friendly!
    </div>

</body>

</html>


<script>
    (function () {

        function escapeHTML(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
        }

        const STATEMENT_KEYWORDS = new Set([
            "import",
            "rule",
            "workflow",
            "ensure",
            "run",
            "prompt",
            "if",
            "then",
            "fi"
        ]);

        /**
         * Tokenizes one Jaiph line while preserving multiline-string state.
         *
         * Args:
         *   line: Source line.
         *   state: Mutable lexer state ({ inString: boolean }).
         * Returns:
         *   Array of token objects.
         */
        function tokenizeJaiphLine(line, state) {
            const tokens = [];
            let i = 0;

            while (i < line.length) {
                const ch = line[i];

                if (state.inString) {
                    const start = i;
                    while (i < line.length) {
                        if (line[i] === '"' && line[i - 1] !== "\\") {
                            i += 1;
                            state.inString = false;
                            break;
                        }
                        i += 1;
                    }
                    tokens.push({ type: "string", value: line.slice(start, i), kind: "string" });
                    continue;
                }

                if (ch === " " || ch === "\t") {
                    const start = i;
                    while (i < line.length && (line[i] === " " || line[i] === "\t")) {
                        i += 1;
                    }
                    tokens.push({ type: "whitespace", value: line.slice(start, i), kind: "plain" });
                    continue;
                }

                if (ch === "/" && line[i + 1] === "/") {
                    tokens.push({ type: "comment", value: line.slice(i), kind: "comment" });
                    break;
                }

                if (ch === "#") {
                    tokens.push({ type: "comment", value: line.slice(i), kind: "comment" });
                    break;
                }

                if (ch === '"') {
                    const start = i;
                    i += 1;
                    while (i < line.length) {
                        if (line[i] === '"' && line[i - 1] !== "\\") {
                            i += 1;
                            break;
                        }
                        i += 1;
                    }
                    if (i >= line.length && line[i - 1] !== '"') {
                        state.inString = true;
                    }
                    tokens.push({ type: "string", value: line.slice(start, i), kind: "string" });
                    continue;
                }

                if (/[A-Za-z_]/.test(ch)) {
                    const start = i;
                    i += 1;
                    while (i < line.length && /[A-Za-z0-9_]/.test(line[i])) {
                        i += 1;
                    }
                    const value = line.slice(start, i);
                    tokens.push({
                        type: "identifier",
                        value: value,
                        kind: "plainIdentifier"
                    });
                    continue;
                }

                if (ch === ".") {
                    tokens.push({ type: "dot", value: ".", kind: "plain" });
                    i += 1;
                    continue;
                }

                tokens.push({ type: "symbol", value: ch, kind: "plain" });
                i += 1;
            }

            return tokens;
        }

        /**
         * Applies semantic meaning to Jaiph tokens (AST-like annotation pass).
         *
         * Args:
         *   tokens: Flat token list for one line.
         * Returns:
         *   New token list with refined token kinds.
         */
        function annotateJaiphTokens(tokens) {
            const annotated = tokens.map(function (token) {
                return { type: token.type, value: token.value, kind: token.kind };
            });

            const significant = annotated
                .map(function (token, index) {
                    return { token: token, index: index };
                })
                .filter(function (entry) {
                    return entry.token.type !== "whitespace" && entry.token.type !== "comment";
                });

            if (significant.length === 0) {
                return annotated;
            }

            const first = significant[0];
            const firstValue = first.token.type === "identifier" ? first.token.value : "";

            if (
                first.token.type === "identifier" &&
                STATEMENT_KEYWORDS.has(firstValue)
            ) {
                annotated[first.index].kind = "keyword";
            }

            if (
                (firstValue === "rule" || firstValue === "workflow") &&
                significant[1] &&
                significant[1].token.type === "identifier"
            ) {
                annotated[significant[1].index].kind = "definition";
            }

            if (firstValue === "import") {
                for (let i = 1; i < significant.length - 1; i += 1) {
                    if (
                        significant[i].token.type === "identifier" &&
                        significant[i].token.value === "as" &&
                        significant[i + 1].token.type === "identifier"
                    ) {
                        annotated[significant[i].index].kind = "keyword";
                        annotated[significant[i + 1].index].kind = "qualifier";
                        break;
                    }
                }
            }

            if (firstValue === "if") {
                for (let i = 1; i < significant.length; i += 1) {
                    if (
                        significant[i].token.type === "identifier" &&
                        significant[i].token.value === "then"
                    ) {
                        annotated[significant[i].index].kind = "keyword";
                    }
                }

                for (let i = 1; i < significant.length - 1; i += 1) {
                    if (
                        significant[i].token.type === "identifier" &&
                        (significant[i].token.value === "ensure" || significant[i].token.value === "run")
                    ) {
                        annotated[significant[i].index].kind = "keyword";
                        if (significant[i + 1].token.type === "identifier") {
                            annotated[significant[i + 1].index].kind = "identifier";
                        }
                        break;
                    }
                }
            }

            for (let i = 0; i < annotated.length - 2; i += 1) {
                if (
                    annotated[i].type === "identifier" &&
                    annotated[i + 1].type === "dot" &&
                    annotated[i + 2].type === "identifier"
                ) {
                    annotated[i].kind = "qualifier";
                    annotated[i + 2].kind = "identifier";
                }
            }

            if (firstValue === "ensure" || firstValue === "run") {
                if (significant[1] && significant[1].token.type === "identifier") {
                    annotated[significant[1].index].kind = "identifier";
                }
            }

            if (firstValue === "ensure") {
                for (let i = 1; i < significant.length; i += 1) {
                    if (
                        significant[i].token.type === "identifier" &&
                        significant[i].token.value === "else"
                    ) {
                        annotated[significant[i].index].kind = "keyword";
                        if (
                            significant[i + 1] &&
                            significant[i + 1].token.type === "identifier" &&
                            significant[i + 1].token.value === "run"
                        ) {
                            annotated[significant[i + 1].index].kind = "keyword";
                            if (significant[i + 2] && significant[i + 2].token.type === "identifier") {
                                annotated[significant[i + 2].index].kind = "identifier";
                            }
                        }
                        break;
                    }
                }
            }

            return annotated;
        }

        /**
         * Builds an AST-like representation for a full Jaiph code block.
         *
         * Args:
         *   raw: Full source block.
         * Returns:
         *   Array of line nodes with annotated tokens.
         */
        function parseJaiph(raw) {
            const state = { inString: false };
            return raw.split("\n").map(function (line, lineIndex) {
                const tokens = tokenizeJaiphLine(line, state);
                return {
                    type: "line",
                    lineNumber: lineIndex + 1,
                    tokens: annotateJaiphTokens(tokens)
                };
            });
        }

        /**
         * Renders one token to highlighted HTML.
         *
         * Args:
         *   token: Annotated token object.
         * Returns:
         *   HTML-safe token string.
         */
        function renderJaiphToken(token) {
            const value = escapeHTML(token.value);
            if (token.kind === "keyword") {
                return `<span class="ralph-keyword">${value}</span>`;
            }
            if (token.kind === "definition") {
                return `<span class="ralph-definition">${value}</span>`;
            }
            if (token.kind === "qualifier") {
                return `<span class="ralph-qualifier">${value}</span>`;
            }
            if (token.kind === "identifier") {
                return `<span class="ralph-identifier">${value}</span>`;
            }
            if (token.kind === "string") {
                return `<span class="ralph-string">${value}</span>`;
            }
            if (token.kind === "comment") {
                return `<span class="ralph-comment">${value}</span>`;
            }
            return value;
        }

        /**
         * Parses and renders Jaiph with line wrappers for numbering.
         *
         * Args:
         *   raw: Full Jaiph source block.
         * Returns:
         *   HTML string containing .code-line rows.
         */
        function highlightJaiphWithParser(raw) {
            const ast = parseJaiph(raw);
            return ast
                .map(function (lineNode) {
                    const html = lineNode.tokens.map(renderJaiphToken).join("");
                    return `<span class="code-line">${html || "&nbsp;"}</span>`;
                })
                .join("");
        }

        function highlightBashFragment(fragment) {
            let code = escapeHTML(fragment);
            const stringTokens = [];
            code = code.replace(/"([^"\\]|\\.)*"|'([^'\\]|\\.)*'/g, function (match) {
                const token = `___BSTR_${stringTokens.length}___`;
                stringTokens.push(match);
                return token;
            });

            code = code.replace(
                /\b(set|source|if|then|fi|local|return|export|function)\b/g,
                '<span class="ralph-keyword">$1</span>'
            );
            code = code.replace(
                /\$[A-Za-z_][A-Za-z0-9_]*/g,
                '<span class="ralph-identifier">$&</span>'
            );

            code = code.replace(/___BSTR_(\d+)___/g, function (_, idx) {
                return `<span class="ralph-string">${stringTokens[Number(idx)]}</span>`;
            });

            return code;
        }

        function highlightBashWithParser(raw) {
            return raw
                .split("\n")
                .map(function (line) {
                    const trimmed = line.trim();
                    if (!trimmed) {
                        return '<span class="code-line">&nbsp;</span>';
                    }
                    if (trimmed.startsWith("#")) {
                        return `<span class="code-line"><span class="ralph-comment">${escapeHTML(line)}</span></span>`;
                    }
                    const fnDeclMatch = line.match(/^(\s*)([A-Za-z_][A-Za-z0-9_]*)(\(\)\s*\{.*)$/);
                    if (fnDeclMatch) {
                        const rendered =
                            escapeHTML(fnDeclMatch[1]) +
                            `<span class="ralph-definition">${fnDeclMatch[2]}</span>` +
                            highlightBashFragment(fnDeclMatch[3]);
                        return `<span class="code-line">${rendered}</span>`;
                    }
                    return `<span class="code-line">${highlightBashFragment(line)}</span>`;
                })
                .join("");
        }

        /**
         * Applies highlighting and line numbers to all pre/code blocks.
         *
         * Args:
         *   None.
         * Returns:
         *   None.
         */
        function highlightAll() {
            document.querySelectorAll("pre code").forEach(block => {
                if (block.matches(".jaiph-run")) {
                    block.dataset.copySource = block.textContent;
                    const html = block.innerHTML;
                    block.innerHTML = html
                        .split("\n")
                        .map(function (line) {
                            return `<span class="code-line">${line || "&nbsp;"}</span>`;
                        })
                        .join("");
                    return;
                }
                const raw = block.textContent;
                block.dataset.copySource = raw;
                const isJaiphBlock = block.matches(".language-ralph, .language-jaiph");
                const isBashBlock = block.matches(".language-bash");
                const rendered = isJaiphBlock
                    ? highlightJaiphWithParser(raw)
                    : isBashBlock
                        ? highlightBashWithParser(raw)
                        : raw
                            .split("\n")
                            .map(function (line) {
                                return `<span class="code-line">${escapeHTML(line) || "&nbsp;"}</span>`;
                            })
                            .join("");
                block.innerHTML = rendered;
            });
        }

        function legacyCopyText(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.setAttribute("readonly", "");
            textArea.style.position = "fixed";
            textArea.style.top = "-9999px";
            textArea.style.left = "-9999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            let copied = false;
            try {
                copied = document.execCommand("copy");
            } catch (_) {
                copied = false;
            }
            document.body.removeChild(textArea);
            return copied;
        }

        async function writeTextToClipboard(text) {
            if (
                window.isSecureContext &&
                navigator.clipboard &&
                typeof navigator.clipboard.writeText === "function"
            ) {
                await navigator.clipboard.writeText(text);
                return true;
            }
            return legacyCopyText(text);
        }

        async function copyCodeFromBlock(button, block) {
            const originalLabel = button.textContent;
            const copySource = block.dataset.copySource != null ? block.dataset.copySource : (block.textContent || "");
            try {
                const copied = await writeTextToClipboard(copySource);
                button.textContent = copied ? "Copied!" : "Copy failed";
            } catch (error) {
                button.textContent = legacyCopyText(copySource) ? "Copied!" : "Copy failed";
            }
            window.setTimeout(function () {
                button.textContent = originalLabel;
            }, 1400);
        }

        function attachCopyButtons() {
            document.querySelectorAll("pre").forEach(function (pre) {
                if (pre.querySelector(".copy-code-button")) {
                    return;
                }
                const block = pre.querySelector("code");
                if (!block) {
                    return;
                }
                const button = document.createElement("button");
                button.type = "button";
                button.className = "copy-code-button";
                button.textContent = "Copy";
                button.addEventListener("click", function () {
                    copyCodeFromBlock(button, block);
                });
                pre.appendChild(button);
            });
        }

        function attachCodeTabs() {
            const buttons = document.querySelectorAll(".code-tab-button");
            buttons.forEach(function (button) {
                button.addEventListener("click", function () {
                    const target = button.getAttribute("data-target");
                    if (!target) {
                        return;
                    }

                    document.querySelectorAll(".code-tab-button").forEach(function (btn) {
                        btn.classList.toggle("is-active", btn === button);
                    });

                    document.querySelectorAll(".code-tab-panel").forEach(function (panel) {
                        panel.classList.toggle("is-active", panel.getAttribute("data-panel") === target);
                    });
                });
            });
        }

        // Auto-run on DOM ready
        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", function () {
                highlightAll();
                attachCopyButtons();
                attachCodeTabs();
            });
        } else {
            highlightAll();
            attachCopyButtons();
            attachCodeTabs();
        }

    })();
</script>